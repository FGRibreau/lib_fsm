<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.3-alpha_snapshot20200131" last-position="0,2" last-zoom="1" max-obj-count="14"
	 default-schema="public" default-owner="postgres">
<role name="api"
      inherit="true"
      encrypted="true"
      password="********">
	<roles names="postgres" role-type="member" />
</role>

<database name="db0" encoding="UTF8" lc-collate="en_US.UTF-8" lc-ctype="en_US.UTF-8" is-template="false" allow-conns="true">
	<role name="postgres"/>
	<tablespace name="pg_default"/>
</database>

<schema name="public" layer="0" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<extension name="pgcrypto" cur-version="1.3">
	<schema name="public"/>
	<comment><![CDATA[cryptographic functions]]></comment>
</extension>

<extension name="citext" handles-type="true" cur-version="1.5">
	<schema name="public"/>
	<comment><![CDATA[data type for case-insensitive character strings]]></comment>
</extension>

<schema name="lib_fsm" layer="0" rect-visible="true" fill-color="#91fd68">
	<role name="postgres"/>
</schema>

<table name="abstract_state_machine" layer="0" collapse-mode="2" rls-enabled="true" max-obj-count="4">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<position x="60" y="80"/>
	<column name="abstract_machine__id" not-null="true" default-value="gen_random_uuid()">
		<type name="uuid" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="30"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<constraint name="abstract_state_machine_name_check" type="ck-constr" table="lib_fsm.abstract_state_machine">
			<expression><![CDATA[(length((name)::text) >= 4)]]></expression>
	</constraint>
	<constraint name="abstract_state_machine_pkey" type="pk-constr" table="lib_fsm.abstract_state_machine">
		<columns names="abstract_machine__id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="abstract_machine_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<parameter name="name$">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="description$" default-value="NULL::text">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    id uuid;
begin
    insert into lib_fsm.abstract_state_machine (abstract_machine__id, name, description)
        values (DEFAULT, name$, description$) returning abstract_machine__id into id;
    return id;
end;]]></definition>
</function>

<function name="abstract_machine_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="abstract_machine__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="name$">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="description$" default-value="NULL::text">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[begin
    update lib_fsm.abstract_state_machine asm
    set name = name$, description = description$
    where asm.abstract_machine__id = abstract_machine__id$;

    if not found then
        raise sqlstate '42P01' using
            message = 'abstract_machine__id not found',
            hint = abstract_machine__id$;
    end if;
end;]]></definition>
</function>

<function name="abstract_machine_delete"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="abstract_machine__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[begin
    delete from lib_fsm.abstract_state_machine
    where lib_fsm.abstract_state_machine.abstract_machine__id = abstract_machine__id$;
end;]]></definition>
</function>

<table name="abstract_state" layer="0" collapse-mode="2" max-obj-count="6">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<comment><![CDATA[Store every state possible for a defined finie state machine (lib_fsm.abstract_state_machine.abstract_machine__id)]]></comment>
	<position x="440" y="160"/>
	<column name="abstract_machine__id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="abstract_state__id" not-null="true" default-value="gen_random_uuid()">
		<type name="uuid" length="0"/>
		<comment><![CDATA[user-defined state name]]></comment>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
		<comment><![CDATA[optional user-defined and user-visible description]]></comment>
	</column>
	<column name="is_initial" not-null="true" default-value="false">
		<type name="boolean" length="0"/>
	</column>
	<constraint name="abstract_state_name_check" type="ck-constr" table="lib_fsm.abstract_state">
			<expression><![CDATA[(length((name)::text) >= 3)]]></expression>
	</constraint>
	<constraint name="abstract_state_pkey" type="pk-constr" table="lib_fsm.abstract_state">
		<columns names="abstract_machine__id,abstract_state__id" ref-type="src-columns"/>
	</constraint>
	<constraint name="abstract_state_abstract_state__id_key" type="uq-constr" table="lib_fsm.abstract_state">
		<columns names="abstract_state__id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="abstract_state_abstract_machine_id_is_initial" table="lib_fsm.abstract_state"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="abstract_machine__id"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="is_initial"/>
		</idxelement>
	<predicate><![CDATA[is_initial = true]]></predicate>
</index>

<function name="ensure_at_least_one_initial_state_per_abstract_machine"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    count int;
begin

    -- We do a short path here if initial already declared unicity constraint will raise an exception.
    if new.is_initial = true then
        return new;
    end if;

    --
    select count(1)
        from lib_fsm.abstract_state as1
        where as1.abstract_machine__id = new.abstract_machine__id
          and as1.is_initial = true
        limit 1
        into count;

    if count = 0 then
        raise 'a state machine must have one initial state. none found.' using errcode = 'check_violation';
    end if;

    return new;
end;]]></definition>
</function>

<trigger name="ensure_at_least_one_initial_state_per_abstract_machine" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="lib_fsm.abstract_state">
		<function signature="lib_fsm.ensure_at_least_one_initial_state_per_abstract_machine()"/>
</trigger>

<function name="abstract_state_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<parameter name="abstract_machine__id">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="description" default-value="NULL::text">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="is_initial" default-value="false">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
    id uuid;
begin
    insert into lib_fsm.abstract_state (abstract_state__id, abstract_machine__id, name, description, is_initial)
        values (default, abstract_machine__id, name, description, is_initial)
        returning abstract_state__id into id;
    return id;
end;]]></definition>
</function>

<table name="abstract_transition" layer="0" collapse-mode="2" max-obj-count="6">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<position x="840" y="340"/>
	<column name="from_abstract_state__id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="to_abstract_state__id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="event" not-null="true">
		<type name="character varying" length="30"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</column>
	<constraint name="abstract_transition_pkey" type="pk-constr" table="lib_fsm.abstract_transition">
		<columns names="from_abstract_state__id,event,to_abstract_state__id" ref-type="src-columns"/>
	</constraint>
	<constraint name="abstract_transition_from_abstract_state__id_event_key" type="uq-constr" table="lib_fsm.abstract_transition">
		<columns names="from_abstract_state__id,event" ref-type="src-columns"/>
	</constraint>
</table>

<function name="ensure_from_and_to_state_have_same_machine__id"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger" length="1"/>
	</return-type>
	<definition><![CDATA[declare
    count int;
begin

    select count(1)
        from lib_fsm.abstract_state as1
        inner join lib_fsm.abstract_state as2 on as2.abstract_state__id = new.to_abstract_state__id
        where as1.abstract_state__id = new.from_abstract_state__id and as1.abstract_machine__id = as2.abstract_machine__id
        limit 1
        into count;

    if count != 1 then
        RAISE 'Both from and to state must have the same machine_id' USING ERRCODE = 'check_violation';
    end if;

    return new;
end;]]></definition>
</function>

<trigger name="ensure_from_and_to_state_have_same_machine__id" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="lib_fsm.abstract_transition">
		<function signature="lib_fsm.ensure_from_and_to_state_have_same_machine__id()"/>
</trigger>

<function name="abstract_transition_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="from_abstract_state__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="event$">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="to_abstract_state__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="description$" default-value="NULL::text">
		<type name="text" length="0"/>
	</parameter>
	<definition><![CDATA[begin
    insert into lib_fsm.abstract_transition(from_abstract_state__id, to_abstract_state__id, event, description)
        values (from_abstract_state__id$, to_abstract_state__id$, event$, description$);
end;]]></definition>
</function>

<view name="abstract_state_machine_transitions" layer="0" collapse-mode="2" max-obj-count="1">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<position x="80" y="360"/>
	<reference>
		<expression><![CDATA[ SELECT ms_previous.abstract_machine__id,
    ms_previous.abstract_state__id AS from_abstract_state__id,
    ms_previous.name AS from_state_name,
    ms_previous.description AS from_state_description,
    mt.event,
    mt.description,
    ms_next.abstract_state__id AS to_abstract_state__id,
    ms_next.name AS to_state_name,
    ms_next.description AS to_state_description
   FROM ((lib_fsm.abstract_transition mt
     JOIN lib_fsm.abstract_state ms_previous ON ((mt.from_abstract_state__id = ms_previous.abstract_state__id)))
     JOIN lib_fsm.abstract_state ms_next ON ((mt.to_abstract_state__id = ms_next.abstract_state__id)));]]></expression>
	<column name="abstract_machine__id">
		<type name="uuid" length="0"/>
	</column>
	<column name="from_abstract_state__id">
		<type name="uuid" length="0"/>
	</column>
	<column name="from_state_name">
		<type name="character varying" length="50"/>
	</column>
	<column name="from_state_description">
		<type name="text" length="0"/>
	</column>
	<column name="event">
		<type name="character varying" length="30"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<column name="to_abstract_state__id">
		<type name="uuid" length="0"/>
	</column>
	<column name="to_state_name">
		<type name="character varying" length="50"/>
	</column>
	<column name="to_state_description">
		<type name="text" length="0"/>
	</column>
		<reftable name="lib_fsm.abstract_state"/>
		<reftable name="lib_fsm.abstract_transition"/>
	</reference>
</view>

<relationship name="rel_abstract_state_machine_transitions_abstract_state" type="reltv" layer="0"
	 custom-color="#0a9572"
	 src-table="lib_fsm.abstract_state_machine_transitions"
	 dst-table="lib_fsm.abstract_state"
	 src-required="false" dst-required="false"/>

<relationship name="rel_abstract_state_machine_transitions_abstract_transition" type="reltv" layer="0"
	 custom-color="#d43ed7"
	 src-table="lib_fsm.abstract_state_machine_transitions"
	 dst-table="lib_fsm.abstract_transition"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="5.17591" y="-5.62948"/>
	</label>
</relationship>

<table name="state_machine" layer="0" collapse-mode="2" max-obj-count="2">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<comment><![CDATA[Store every state possible for a defined finite state machine (lib_fsm.abstract_state_machine.abstract_machine__id)]]></comment>
	<position x="940" y="120"/>
	<column name="state_machine__id" not-null="true" default-value="gen_random_uuid()">
		<type name="uuid" length="0"/>
		<comment><![CDATA[one of ]]></comment>
	</column>
	<column name="abstract_state__id" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<constraint name="state_machine_pkey" type="pk-constr" table="lib_fsm.state_machine">
		<columns names="state_machine__id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="state_machine_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="uuid" length="1"/>
	</return-type>
	<parameter name="abstract_state_machine__id_or_abstract_state__id">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  initial_abstract_state__id uuid;
  id uuid;
begin

  select abstract_state__id into initial_abstract_state__id
    from lib_fsm.abstract_state abst
    where abst.abstract_machine__id = abstract_state_machine__id_or_abstract_state__id
      and is_initial = true;

  if not found then
    -- Then provided id is either an abstract state id or not linked uiid.
    initial_abstract_state__id = abstract_state_machine__id_or_abstract_state__id;
  end if;

  insert into lib_fsm.state_machine (state_machine__id, abstract_state__id)
    values (default, initial_abstract_state__id)
    returning state_machine__id into id;
    return id;
end;]]></definition>
</function>

<function name="state_machine_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="state_machine__id">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[declare
  state record;
begin

  select abstract_state__id, name, description into state
    from lib_fsm.state_machine
    inner join lib_fsm.abstract_state using (abstract_state__id)
    where  lib_fsm.state_machine.state_machine__id = state_machine_get.state_machine__id;

  if not found then
    raise sqlstate '42P01' using
      message = 'state_machine__id not found',
      hint = state_machine__id;
  end if;
  return state;
end;]]></definition>
</function>

<function name="state_machine_delete"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="1"/>
	</return-type>
	<parameter name="state_machine__id">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[begin

  delete from lib_fsm.state_machine
    where lib_fsm.state_machine.state_machine__id = state_machine_delete.state_machine__id;
end;]]></definition>
</function>

<function name="state_machine_transition"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="record" length="1"/>
	</return-type>
	<parameter name="state_machine__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<parameter name="event$">
		<type name="character varying" length="0"/>
	</parameter>
	<parameter name="dry_run$" default-value="false">
		<type name="boolean" length="0"/>
	</parameter>
	<definition><![CDATA[declare
   to_state record;
begin

  -- ensure event is a valid next state for `state_machine__id`
  select ast.abstract_state__id, ast.name, ast.description into to_state
    from lib_fsm.state_machine sm
    inner join lib_fsm.abstract_transition abtr on abtr.from_abstract_state__id = sm.abstract_state__id
    inner join lib_fsm.abstract_state ast on ast.abstract_state__id = abtr.to_abstract_state__id
    where sm.state_machine__id = state_machine__id$
      and abtr.event = event$;

  -- if no next state => raise an exception
  if not found then
    raise sqlstate 'P0001' using
    message = 'Invalid event for this machine';
  end if;

  -- if dry_run mode stop there and yield the to_state record
  if dry_run$ = true then
    return to_state;
  end if;

  -- update state machine to next state
  update lib_fsm.state_machine set abstract_state__id = to_state.abstract_state__id
    where state_machine.state_machine__id = state_machine__id$;

  return to_state;
end;]]></definition>
</function>

<function name="state_machine_get_next_transitions"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="lib_fsm.abstract_state_machine_transitions" length="1"/>
	</return-type>
	<parameter name="state_machine__id$">
		<type name="uuid" length="0"/>
	</parameter>
	<definition><![CDATA[begin
  return query select asmt.*
    from lib_fsm.abstract_state_machine_transitions asmt
    where asmt.from_abstract_state__id = (
        select abstract_state__id
          from lib_fsm.state_machine sm
          where sm.state_machine__id = state_machine__id$
      );
end;]]></definition>
</function>

<table name="test_contract_version" layer="0" collapse-mode="2" max-obj-count="6">
	<schema name="lib_fsm"/>
	<role name="postgres"/>
	<position x="1380" y="220"/>
	<column name="contract_version__id" not-null="true" default-value="gen_random_uuid()">
		<type name="uuid" length="0"/>
	</column>
	<column name="validity" not-null="true" default-value="tstzrange(now(), 'infinity'::timestamp with time zone)">
		<type name="tstzrange" length="0"/>
	</column>
	<column name="status1" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="status2" not-null="true">
		<type name="uuid" length="0"/>
	</column>
	<column name="description">
		<type name="text" length="0"/>
	</column>
	<constraint name="test_contract_version_description_check" type="ck-constr" table="lib_fsm.test_contract_version">
			<expression><![CDATA[((length(description) > 10) AND (length(description) < 500))]]></expression>
	</constraint>
	<constraint name="test_contract_version_pkey" type="pk-constr" table="lib_fsm.test_contract_version">
		<columns names="contract_version__id" ref-type="src-columns"/>
	</constraint>
</table>

<policy name="fsm_machines_access_policy" table="lib_fsm.abstract_state_machine" command="ALL" permissive="true">

	<expression type="using-exp"><![CDATA[iam.can_i('fsm'::text, 'machines'::text, 'list'::text)]]></expression>
	<expression type="check-exp"><![CDATA[iam.can_i('fsm'::text, 'machines'::text, 'update'::text) OR iam.can_i('fsm'::text, 'machines'::text, 'create'::text) OR iam.can_i('fsm'::text, 'machines'::text, 'delete'::text)]]></expression>
</policy>
<constraint name="abstract_state_abstract_machine__id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.abstract_state_machine" table="lib_fsm.abstract_state">
	<columns names="abstract_machine__id" ref-type="src-columns"/>
	<columns names="abstract_machine__id" ref-type="dst-columns"/>
</constraint>

<constraint name="abstract_transition_from_abstract_state__id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.abstract_state" table="lib_fsm.abstract_transition">
	<columns names="from_abstract_state__id" ref-type="src-columns"/>
	<columns names="abstract_state__id" ref-type="dst-columns"/>
</constraint>

<constraint name="abstract_transition_to_abstract_state__id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.abstract_state" table="lib_fsm.abstract_transition">
	<columns names="to_abstract_state__id" ref-type="src-columns"/>
	<columns names="abstract_state__id" ref-type="dst-columns"/>
</constraint>

<constraint name="state_machine_abstract_state__id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.abstract_state" table="lib_fsm.state_machine">
	<columns names="abstract_state__id" ref-type="src-columns"/>
	<columns names="abstract_state__id" ref-type="dst-columns"/>
</constraint>

<constraint name="test_contract_version_status1_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.state_machine" table="lib_fsm.test_contract_version">
	<columns names="status1" ref-type="src-columns"/>
	<columns names="state_machine__id" ref-type="dst-columns"/>
</constraint>

<constraint name="test_contract_version_status2_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="lib_fsm.state_machine" table="lib_fsm.test_contract_version">
	<columns names="status2" ref-type="src-columns"/>
	<columns names="state_machine__id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_abstract_state_abstract_state_machine" type="relfk" layer="0"
	 custom-color="#6b50b9"
	 src-table="lib_fsm.abstract_state"
	 dst-table="lib_fsm.abstract_state_machine" reference-fk="abstract_state_abstract_machine__id_fkey"
	 src-required="false" dst-required="false"/>

<relationship name="rel_abstract_transition_abstract_state" type="relfk" layer="0"
	 custom-color="#33568c"
	 src-table="lib_fsm.abstract_transition"
	 dst-table="lib_fsm.abstract_state" reference-fk="abstract_transition_from_abstract_state__id_fkey"
	 src-required="false" dst-required="false"/>

<relationship name="rel_abstract_transition_abstract_state1" type="relfk" layer="0"
	 custom-color="#5ed894"
	 src-table="lib_fsm.abstract_transition"
	 dst-table="lib_fsm.abstract_state" reference-fk="abstract_transition_to_abstract_state__id_fkey"
	 src-required="false" dst-required="false"/>

<relationship name="rel_state_machine_abstract_state" type="relfk" layer="0"
	 custom-color="#734368"
	 src-table="lib_fsm.state_machine"
	 dst-table="lib_fsm.abstract_state" reference-fk="state_machine_abstract_state__id_fkey"
	 src-required="false" dst-required="false"/>

<relationship name="rel_test_contract_version_state_machine" type="relfk" layer="0"
	 custom-color="#0e501d"
	 src-table="lib_fsm.test_contract_version"
	 dst-table="lib_fsm.state_machine" reference-fk="test_contract_version_status1_fkey"
	 src-required="false" dst-required="false"/>

<relationship name="rel_test_contract_version_state_machine1" type="relfk" layer="0"
	 custom-color="#266a91"
	 src-table="lib_fsm.test_contract_version"
	 dst-table="lib_fsm.state_machine" reference-fk="test_contract_version_status2_fkey"
	 src-required="false" dst-required="false"/>

<permission>
	<object name="lib_fsm" type="schema"/>
	<roles names="postgres"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="lib_fsm" type="schema"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_state_machine" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_state_machine" type="table"/>
	<roles names="api"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_state" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_state" type="table"/>
	<roles names="api"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_transition" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="lib_fsm.abstract_transition" type="table"/>
	<roles names="api"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="lib_fsm.state_machine" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="lib_fsm.state_machine" type="table"/>
	<roles names="api"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
</dbmodel>
